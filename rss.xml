<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>老运维人员</title><link>http://opslinux.com/</link><description></description><atom:link href="http://opslinux.com/rss.xml" rel="self"></atom:link><lastBuildDate>Fri, 24 Jan 2014 15:33:00 +0800</lastBuildDate><item><title>HTTP Header 详解</title><link>http://opslinux.com/post/2014-01-24-http-header-xiang-jie/</link><description>&lt;p&gt;HTTP（HyperTextTransferProtocol）即超文本传输协议，目前网页传输的的通用协议。HTTP协议采用了请求/响应模型，浏览器或其他客户端发出请求，服务器给与响应。就整个网络资源传输而言，包括message-header和message-body两部分。首先传递message- header，即http header消息 。http header 消息通常被分为4个部分：general  header, request header, response header, entity header。但是这种分法就理解而言，感觉界限不太明确。根据维基百科对http header内容的组织形式，大体分为Request和Response两部分。&lt;/p&gt;
&lt;p&gt;Requests部分&lt;/p&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: ERROR/3 (&lt;tt class="docutils"&gt;/Users/ce/workspace/pelican/blog/content/HTTP Header详解.rst&lt;/tt&gt;, line 33)&lt;/p&gt;
&lt;p&gt;Malformed table.
Text in column margin in table line 21.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
====================================== ======================================================================================== =====================================================================================================
Header                                 解释                                                                                       示例
====================================== ======================================================================================== =====================================================================================================
Accept                                 指定客户端能够接收的内容类型                                                                     Accept: text/plain, text/html
Accept-Charset                         浏览器可以接受的字符编码集                                                                       Accept-Charset: iso-8859-5
Accept-Encoding                        指定浏览器可以支持的web服务器返回内容压缩编码类型                                                   Accept-Encoding: compress, gzip
Accept-Language                        浏览器可接受的语言                                                                              Accept-Language: en,zh
Accept-Ranges                          可以请求网页实体的一个或者多个子范围字段                                                           Accept-Ranges: bytes
Authorization                          HTTP授权的授权证书                                                                             Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
Cache-Control                          指定请求和响应遵循的缓存机制                                                                     Cache-Control: no-cache
Connection                             表示是否需要持久连接。（HTTP 1.1默认进行持久连接）                                                 Connection: close
CookieHTTP                             请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。                                 Cookie: $Version=1; Skin=new;
Content-Length                         请求的内容长度                                                                                  Content-Length: 348
Content-Type                           请求的与实体对应的MIME信息                                                                       Content-Type: application/x-www-form-urlencoded
Date                                   请求发送的日期和时间                                                                             Date: Tue, 15 Nov 2010 08:12:31 GMT
Expect                                 请求的特定的服务器行为                                                                           Expect: 100-continue
From                                   发出请求的用户的Email                                                                            From: user&amp;#64;email.com
Host                                   指定请求的服务器的域名和端口号                                                                     Host: www.zcmhi.com
If-Match                               只有请求内容与实体相匹配才有效                                                                      If-Match: “737060cd8c284d8af7ad3082f209582d”
If-Modified-Since                      如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码                                     If-Modified-Since: Sat, 29 Oct 2010 19:43:31 GMT
If-None-Match                          如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变                  If-None-Match: “737060cd8c284d8af7ad3082f209582d”
If-Range                               如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag                                If-Range: “737060cd8c284d8af7ad3082f209582d”
If-Unmodified-Since                    只在实体在指定时间之后未被修改才请求成功                                                            If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT
Max-Forwards                           限制信息通过代理和网关传送的时间                                                                   Max-Forwards: 10
Pragma                                 用来包含实现特定的指令                                                                            Pragma: no-cache
Proxy-Authorization                    连接到代理的授权证书                                                                              Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
Range                                  只请求实体的一部分，指定范围                                                                       Range: bytes=500-999
Referer                                先前网页的地址，当前请求网页紧随其后,即来路                                                          Referer: http://www.zcmhi.com/archives/71.html
TE                                     客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息                                               TE: trailers,deflate;q=0.5
Upgrade                                向服务器指定某种传输协议以便服务器进行转换（如果支持）                                                Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
User-Agent                             User-Agent的内容包含发出请求的用户信息                                                            User-Agent: Mozilla/5.0 (Linux; X11)
Via                                    通知中间网关或代理服务器地址，通信协议                                                             Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1)
Warning                                关于消息实体的警告信息                                                                           Warn: 199 Miscellaneous warning
====================================== ======================================================================================== =====================================================================================================
&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;Responses 部分&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">创e</dc:creator><pubDate>Fri, 24 Jan 2014 15:33:00 +0800</pubDate><guid>tag:opslinux.com,2014-01-24:post/2014-01-24-http-header-xiang-jie/</guid><category>HTTP</category></item><item><title>python中的urlencode与urldecode</title><link>http://opslinux.com/post/2013-11-01-pythonzhong-de-urlencodeyu-urldecode/</link><description>
&lt;p&gt;转载： &lt;a class="reference external" href="http://luchanghong.com/python/2012/07/11/python-urlencode-and-urldecode.html"&gt;地址&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;概要：python 通过 HTTP 交互处理数据的时候，url 里面的中文以及特殊字符要做处理的，来学习一下 urlencode 与 urldecode 之间相互转换的方法。
当url地址含有中文，或者参数有中文的时候，这个算是很正常了，但是把这样的url作为参数传递的时候（最常见的callback），需要把一些中文甚至'/'做一下编码转换。&lt;/p&gt;
&lt;div class="section" id="urlencode"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;一、urlencode&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;urllib库里面有个urlencode函数，可以把key-value这样的键值对转换成我们想要的格式，返回的是a=1&amp;amp;b=2这样的字符串，比如:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; from urllib import urlencode
&amp;gt;&amp;gt;&amp;gt; data = {
...     'a': 'test',
...     'name': '魔兽'
... }
&amp;gt;&amp;gt;&amp;gt; print urlencode(data)
a=test&amp;amp;amp;name=%C4%A7%CA%DE
&lt;/pre&gt;
&lt;p&gt;如果只想对一个字符串进行urlencode转换，怎么办？urllib提供另外一个函数：quote()&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; from urllib import quote
&amp;gt;&amp;gt;&amp;gt; quote('魔兽')
'%C4%A7%CA%DE'
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="urldecode"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;二、urldecode&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;当urlencode之后的字符串传递过来之后，接受完毕就要解码了——urldecode。urllib提供了unquote()这个函数，可没有urldecode()！:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; from urllib import unquote
&amp;gt;&amp;gt;&amp;gt; unquote('%C4%A7%CA%DE')
'\xc4\xa7\xca\xde'
&amp;gt;&amp;gt;&amp;gt; print unquote('%C4%A7%CA%DE')
魔兽
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;三、讨论&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在做urldecode的时候，看unquote()这个函数的输出，是对应中文在gbk下的编码，在对比一下quote()的结果不难发现，所谓的urlencode就是把字符串转车gbk编码，然后把\x替换成%。如果你的终端是utf8编码的，那么要把结果再转成utf8输出，否则就乱码。&lt;/p&gt;
&lt;p&gt;可以根据实际情况，自定义或者重写urlencode()、urldecode()等函数。&lt;/p&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">创e</dc:creator><pubDate>Fri, 01 Nov 2013 12:51:00 +0800</pubDate><guid>tag:opslinux.com,2013-11-01:post/2013-11-01-pythonzhong-de-urlencodeyu-urldecode/</guid><category>python</category></item><item><title>Nginx打造3w高并发网站</title><link>http://opslinux.com/post/2013-10-25-nginxda-zao-3wgao-bing-fa-wang-zhan/</link><description>
&lt;p&gt;Nginx是俄罗斯人编写的十分轻量级的HTTP服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器．Nginx是由俄罗斯人 Igor Sysoev为俄罗斯访问量第二的 Rambler.ru站点开发.&lt;/p&gt;
&lt;p&gt;Nginx以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡。其拥有匹配 Lighttpd的性能，同时还没有Lighttpd的内存泄漏问题，而且Lighttpd的mod_proxy也有一些问题并且很久没有更新。但是Nginx并不支持cgi方式运行，原因是可以减少因此带来的一些程序上的漏洞。所以必须使用FastCGI方式来执行PHP程序。&lt;/p&gt;
&lt;p&gt;nginx做为HTTP服务器，有以下几项基本特性：&lt;/p&gt;
&lt;p&gt;处理静态文件，索引文件以及自动索引；打开文件描述符缓冲．&lt;/p&gt;
&lt;p&gt;无缓存的反向代理加速，简单的负载均衡和容错．&lt;/p&gt;
&lt;p&gt;FastCGI，简单的负载均衡和容错．&lt;/p&gt;
&lt;p&gt;模块化的结构。包括gzipping, byte ranges, chunked responses,以及 SSI-filter等filter。如果由FastCGI或其它代理服务器处理单页中存在的多个SSI，则这项处理可以并行运行，而不需要相互等待。&lt;/p&gt;
&lt;p&gt;Nginx专为性能优化而开发，性能是其最重要的考量,实现上非常注重效率。它支持内核Poll模型，能经受高负载的考验,有报告表明能支持高达 50,000个并发连接数。&lt;/p&gt;
&lt;p&gt;Nginx具有很高的稳定性。其它HTTP服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前apache一旦上到200个以上进程，web响应速度就明显非常缓慢了。而Nginx采取了分阶段资源分配技术，使得它的CPU与内存占用率非常低。nginx官方表示保持10,000个没有活动的连接，它只占2.5M内存，所以类似DOS这样的攻击对nginx来说基本上是毫无用处的。就稳定性而言,nginx比lighthttpd更胜一筹。&lt;/p&gt;
&lt;p&gt;Nginx支持热部署。它的启动特别容易, 并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在不间断服务的情况下，对软件版本进行进行升级。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id10"&gt;编译安装过程优化&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在编译Nginx时，默认以debug模式进行，而在debug模式下会插入很多跟踪和ASSERT之类的信息，编译完成后，一个Nginx要有好几兆字节。在编译前取消Nginx的debug模式，编译完成后Nginx只有几百千字节，因此可以在编译之前，修改相关源码，取消debug模式，具体方法如下：
在Nginx源码文件被解压后，找到源码目录下的auto/cc/gcc文件，在其中找到如下几行:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
# debug
CFLAGS=”$CFLAGS -g”
&lt;/pre&gt;
&lt;div class="section" id="cpucpu"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id11"&gt;为特定的CPU指定CPU类型编译优化&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在编译Nginx时，默认的GCC编译参数是“-O”，要优化GCC编译，可以使用以下两个参数:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
--with-cc-opt='-O3'
--with-cpu-opt=CPU  #为特定的 CPU 编译，有效的值包括：pentium, pentiumpro, pentium3, pentium4, athlon, opteron, amd64, sparc32, sparc64, ppc64
&lt;/pre&gt;
&lt;p&gt;要确定CPU类型，可以通过如下命令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[root@localhost home]#cat /proc/cpuinfo | grep "model name"
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="tcmallocnginx"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id12"&gt;利用TCMalloc优化Nginx的性能&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;TCMalloc的全称为Thread-Caching Malloc，是谷歌开发的开源工具“google-perftools”中的一个成员。与标准的glibc库的malloc相比，TCMalloc库在内存分配效率和速度上要高很多，这在很大程度上提高了服务器在高并发情况下的性能，从而降低系统负载。下面简单介绍如何为Nginx添加TCMalloc库支持。
要安装TCMalloc库，需要安装libunwind（32位操作系统不需要安装）和google-perftools两个软件包，libunwind库为基于64位CPU和操作系统的程序提供了基本函数调用链和函数调用寄存器功能。下面介绍利用TCMalloc优化Nginx的具体操作过程：&lt;/p&gt;
&lt;div class="section" id="libunwind"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id13"&gt;1.安装libunwind库&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;可以从http://download.savannah.gnu.org/releases/libunwind下载相应的libunwind版本，这里下载的是libunwind-0.99-alpha.tar.gz，安装过程如下&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[root@localhost home]#tar zxvf libunwind-0.99-alpha.tar.gz
[root@localhost home]# cd libunwind-0.99-alpha/
[root@localhost libunwind-0.99-alpha]#CFLAGS=-fPIC ./configure
[root@localhost libunwind-0.99-alpha]#make CFLAGS=-fPIC
[root@localhost libunwind-0.99-alpha]#make CFLAGS=-fPIC install
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="google-perftools"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id14"&gt;2.安装google-perftools&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;可以从http://google-perftools.googlecode.com下载相应的google-perftools版本，这里下载的是google-perftools-1.8.tar.gz，安装过程如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[root@localhost home]# tar zxvf google-perftools-1.8.tar.gz
[root@localhost home]# cd google-perftools-1.8/
[root@localhost google-perftools-1.8]# ./configure
[root@localhost google-perftools-1.8]# make &amp;amp;&amp;amp; make install
[root@localhost google-perftools-1.8]# echo "/usr/local/lib" &amp;gt; /etc/ld.so.conf.d/usr_local_lib.conf
[root@localhost google-perftools-1.8]# ldconfig
&lt;/pre&gt;
&lt;p&gt;至此，google-perftools安装完成。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="nginx"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id15"&gt;3.重新编译Nginx&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;为了使Nginx支持google-perftools，需要在安装过程中添加“–with-google_perftools_module”选项重新编译Nginx，安装代码如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[root@localhostnginx-0.7.65]#./configure \
&amp;gt;--with-google_perftools_module --with-http_stub_status_module  --prefix=/opt/nginx
[root@localhost nginx-0.7.65]#make
[root@localhost nginx-0.7.65]#make install
&lt;/pre&gt;
&lt;p&gt;到这里Nginx安装完成。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id16"&gt;4.为google-perftools添加线程目录&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;创建一个线程目录，这里将文件放在/tmp/tcmalloc下，操作如下:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[root@localhost home]#mkdir /tmp/tcmalloc
[root@localhost home]#chmod 0777 /tmp/tcmalloc
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id17"&gt;5.修改Nginx主配置文件&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;修改nginx.conf文件，在pid这行的下面添加如下代码:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#pid        logs/nginx.pid;
google_perftools_profiles /tmp/tcmalloc;
&lt;/pre&gt;
&lt;p&gt;接着，重启Nginx，完成google-perftools的加载。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id4"&gt;
&lt;h4&gt;&lt;a class="toc-backref" href="#id18"&gt;6.验证运行状态&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;为了验证google-perftools已经正常加载，通过如下命令查看:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[root@ localhost home]# lsof -n | grep tcmalloc
nginx      2395 nobody   9w  REG    8,8       0    1599440 /tmp/tcmalloc.2395
nginx      2396 nobody   11w REG   8,8       0    1599443 /tmp/tcmalloc.2396
nginx      2397 nobody   13w REG  8,8        0    1599441  /tmp/tcmalloc.2397
nginx     2398 nobody    15w REG  8,8     0    1599442 /tmp/tcmalloc.2398
&lt;/pre&gt;
&lt;p&gt;由于在Nginx配置文件中，设置worker_processes的值为4，因此开启了4个Nginx线程，每个线程会有一行记录。每个线程文件后面的数字值就是启动的Nginx的PID值。
至此，利用TCMalloc优化Nginx的操作完成。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="id5"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id19"&gt;Nginx内核参数优化&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;内核参数的优化，主要是在Linux系统中针对Nginx应用而进行的系统内核参数优化，常见的优化参数值如下。&lt;/p&gt;
&lt;p&gt;下面给出一个优化实例以供参考:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
net.ipv4.tcp_max_tw_buckets = 6000
net.ipv4.ip_local_port_range = 1024 65000
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_syncookies = 1
net.core.somaxconn = 262144
net.core.netdev_max_backlog = 262144
net.ipv4.tcp_max_orphans = 262144
net.ipv4.tcp_max_syn_backlog = 262144
net.ipv4.tcp_synack_retries = 1
net.ipv4.tcp_syn_retries = 1
net.ipv4.tcp_fin_timeout = 1
net.ipv4.tcp_keepalive_time = 30
&lt;/pre&gt;
&lt;p&gt;将上面的内核参数值加入/etc/sysctl.conf文件中，然后执行如下命令使之生效:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[root@ localhost home]#/sbin/sysctl -p
&lt;/pre&gt;
&lt;p&gt;下面是对实例中选项的含义进行介绍：&lt;/p&gt;
&lt;p&gt;net.ipv4.tcp_max_tw_buckets参数用来设定timewait的数量，默认是180000，这里设为6000。&lt;/p&gt;
&lt;p&gt;net.ipv4.ip_local_port_range选项用来设定允许系统打开的端口范围。&lt;/p&gt;
&lt;p&gt;net.ipv4.tcp_tw_recycle选项用于设置启用timewait快速回收。&lt;/p&gt;
&lt;p&gt;net.ipv4.tcp_tw_reuse选项用于设置开启重用，允许将TIME-WAIT sockets重新用于新的TCP连接。&lt;/p&gt;
&lt;p&gt;net.ipv4.tcp_syncookies选项用于设置开启SYN Cookies，当出现SYN等待队列溢出时，启用cookies进行处理。&lt;/p&gt;
&lt;p&gt;net.core.somaxconn选项默认值是128， 这个参数用于调节系统同时发起的tcp连接数，在高并发的请求中，默认的值可能会导致链接超时或者重传，因此，需要结合并发请求数来调节此值。&lt;/p&gt;
&lt;p&gt;net.core.netdev_max_backlog选项表示当每个网络接口接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目。&lt;/p&gt;
&lt;p&gt;net.ipv4.tcp_max_orphans选项用于设定系统中最多有多少个TCP套接字不被关联到任何一个用户文件句柄上。如果超过这个数字，孤立连接将立即被复位并打印出警告信息。这个限制只是为了防止简单的DoS攻击。不能过分依靠这个限制甚至人为减小这个值，更多的情况是增加这个值。&lt;/p&gt;
&lt;p&gt;net.ipv4.tcp_max_syn_backlog选项用于记录那些尚未收到客户端确认信息的连接请求的最大值。对于有128MB内存的系统而言，此参数的默认值是1024，对小内存的系统则是128。&lt;/p&gt;
&lt;p&gt;net.ipv4.tcp_synack_retries参数的值决定了内核放弃连接之前发送SYN+ACK包的数量。&lt;/p&gt;
&lt;p&gt;net.ipv4.tcp_syn_retries选项表示在内核放弃建立连接之前发送SYN包的数量。&lt;/p&gt;
&lt;p&gt;net.ipv4.tcp_fin_timeout选项决定了套接字保持在FIN-WAIT-2状态的时间。默认值是60秒。正确设置这个值非常重要，有时候即使一个负载很小的Web服务器，也会出现因为大量的死套接字而产生内存溢出的风险。&lt;/p&gt;
&lt;p&gt;net.ipv4.tcp_keepalive_time选项表示当keepalive启用的时候，TCP发送keepalive消息的频度。默认值是2（单位是小时）。&lt;/p&gt;
&lt;p&gt;下面贴一个完整的内核优化设置:&lt;/p&gt;
&lt;p&gt;vi /etc/sysctl.conf CentOS5.5中可以将所有内容清空直接替换为如下内容:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
net.ipv4.ip_forward = 0
net.ipv4.conf.default.rp_filter = 1
net.ipv4.conf.default.accept_source_route = 0
kernel.sysrq = 0
kernel.core_uses_pid = 1
net.ipv4.tcp_syncookies = 1
kernel.msgmnb = 65536
kernel.msgmax = 65536
kernel.shmmax = 68719476736
kernel.shmall = 4294967296
net.ipv4.tcp_max_tw_buckets = 6000
net.ipv4.tcp_sack = 1
net.ipv4.tcp_window_scaling = 1
net.ipv4.tcp_rmem = 4096 87380 4194304
net.ipv4.tcp_wmem = 4096 16384 4194304
net.core.wmem_default = 8388608
net.core.rmem_default = 8388608
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.core.netdev_max_backlog = 262144
net.core.somaxconn = 262144
net.ipv4.tcp_max_orphans = 3276800
net.ipv4.tcp_max_syn_backlog = 262144
net.ipv4.tcp_timestamps = 0
net.ipv4.tcp_synack_retries = 1
net.ipv4.tcp_syn_retries = 1
net.ipv4.tcp_tw_recycle = 1
net.ipv4.tcp_tw_reuse = 1
net.ipv4.tcp_mem = 94500000 915000000 927000000
net.ipv4.tcp_fin_timeout = 1
net.ipv4.tcp_keepalive_time = 30
net.ipv4.ip_local_port_range = 1024 65000
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="id6"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id20"&gt;配置文件优化&lt;/a&gt;&lt;/h2&gt;
&lt;div class="section" id="id7"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id21"&gt;基本优化&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一般来说nginx 配置文件中对优化比较有作用的为以下几项：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;worker_processes 8;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;nginx 进程数，建议按照cpu 数目来指定，一般为它的倍数 (如,2个四核的cpu计为8)。&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为每个进程分配cpu，上例中将8 个进程分配到8 个cpu，当然可以写多个，或者将一
个进程分配到多个cpu。&lt;/p&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;worker_rlimit_nofile 65535;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个指令是指当一个nginx 进程打开的最多文件描述符数目，理论值应该是最多打开文
件数（ulimit -n）与nginx 进程数相除，但是nginx 分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。详见&lt;a class="reference internal" href="#ulimit"&gt;ulimit关于系统连接数的优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现在在linux 2.6内核下开启文件打开数为65535，worker_rlimit_nofile就相应应该填写65535。&lt;/p&gt;
&lt;p&gt;这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。&lt;/p&gt;
&lt;p&gt;查看linux系统文件描述符的方法:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
[root@web001 ~]# sysctl -a | grep fs.file

fs.file-max = 789972

fs.file-nr = 510 0 789972
&lt;/pre&gt;
&lt;ol class="arabic simple" start="4"&gt;
&lt;li&gt;use epoll;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;使用epoll 的I/O 模型&lt;/p&gt;
&lt;p&gt;(&lt;/p&gt;
&lt;p&gt;补充说明:&lt;/p&gt;
&lt;p&gt;与apache相类，nginx针对不同的操作系统，有不同的事件模型&lt;/p&gt;
&lt;p&gt;A）标准事件模型
Select、poll属于标准事件模型，如果当前系统不存在更有效的方法，nginx会选择select或poll
B）高效事件模型
Kqueue：使用于 FreeBSD 4.1+, OpenBSD 2.9+, NetBSD 2.0 和 MacOS X. 使用双处理器的MacOS X系统使用kqueue可能会造成内核崩溃。
Epoll: 使用于Linux内核2.6版本及以后的系统。&lt;/p&gt;
&lt;p&gt;/dev/poll：使用于 Solaris 7 11/99+, HP/UX 11.22+ (eventport), IRIX 6.5.15+ 和 Tru64 UNIX 5.1A+。&lt;/p&gt;
&lt;p&gt;Eventport：使用于 Solaris 10. 为了防止出现内核崩溃的问题， 有必要安装安全补丁。&lt;/p&gt;
&lt;p&gt;)&lt;/p&gt;
&lt;ol class="arabic simple" start="5"&gt;
&lt;li&gt;worker_connections 65535;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个进程允许的最多连接数， 理论上每台nginx 服务器的最大连接数为worker_processes*worker_connections。&lt;/p&gt;
&lt;ol class="arabic simple" start="6"&gt;
&lt;li&gt;keepalive_timeout 60;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;keepalive 超时时间。&lt;/p&gt;
&lt;ol class="arabic simple" start="7"&gt;
&lt;li&gt;client_header_buffer_size 4k;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求头的大小不会超过1k，不过由于一般系统分页都要大于1k，所以这里设置为分页大小。&lt;/p&gt;
&lt;p&gt;分页大小可以用命令getconf PAGESIZE 取得。&lt;/p&gt;
&lt;p&gt;[&lt;a class="reference external" href="mailto:root@web001"&gt;root@web001&lt;/a&gt; ~]# getconf PAGESIZE&lt;/p&gt;
&lt;p&gt;4096&lt;/p&gt;
&lt;p&gt;但也有client_header_buffer_size超过4k的情况，但是client_header_buffer_size该值必须设置为“系统分页大小”的整倍数。&lt;/p&gt;
&lt;ol class="arabic simple" start="8"&gt;
&lt;li&gt;open_file_cache max=65535 inactive=60s;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个将为打开文件指定缓存，默认是没有启用的，max 指定缓存数量，建议和打开文件数一致，inactive 是指经过多长时间文件没被请求后删除缓存。&lt;/p&gt;
&lt;ol class="arabic simple" start="9"&gt;
&lt;li&gt;open_file_cache_valid 80s;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个是指多长时间检查一次缓存的有效信息。&lt;/p&gt;
&lt;ol class="arabic simple" start="10"&gt;
&lt;li&gt;open_file_cache_min_uses 1;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;open_file_cache 指令中的inactive 参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive 时间内一次没被使用，它将被移除。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id8"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id22"&gt;简单配置文件&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;下面是一个简单的nginx 配置文件:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
user www www;
worker_processes 8;
worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000
01000000;
error_log /www/log/nginx_error.log crit;
pid /usr/local/nginx/nginx.pid;
worker_rlimit_nofile 204800;
events
{
use epoll;
worker_connections 204800;
}
http
{
include mime.types;
default_type application/octet-stream;
charset utf-8;
server_names_hash_bucket_size 128;
client_header_buffer_size 2k;
large_client_header_buffers 4 4k;
client_max_body_size 8m;
sendfile on;
tcp_nopush on;
keepalive_timeout 60;
fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2
keys_zone=TEST:10m
inactive=5m;
fastcgi_connect_timeout 300;
fastcgi_send_timeout 300;
fastcgi_read_timeout 300;
fastcgi_buffer_size 4k;
fastcgi_buffers 8 4k;
fastcgi_busy_buffers_size 8k;
fastcgi_temp_file_write_size 8k;
fastcgi_cache TEST;
fastcgi_cache_valid 200 302 1h;
fastcgi_cache_valid 301 1d;
fastcgi_cache_valid any 1m;
fastcgi_cache_min_uses 1;
fastcgi_cache_use_stale error timeout invalid_header http_500;
open_file_cache max=204800 inactive=20s;
open_file_cache_min_uses 1;
open_file_cache_valid 30s;
tcp_nodelay on;
gzip on;
gzip_min_length 1k;
gzip_buffers 4 16k;
gzip_http_version 1.0;
gzip_comp_level 2;
gzip_types text/plain application/x-javascript text/css application/xml;
gzip_vary on;
server
{
listen 8080;
server_name backup.aiju.com;
index index.php index.htm;
root /www/html/;
location /status
{
stub_status on;
}
location ~ .*\.(php|php5)?$
{
fastcgi_pass 127.0.0.1:9000;
fastcgi_index index.php;
include fcgi.conf;
}
location ~ .*\.(gif|jpg|jpeg|png|bmp|swf|js|css)$
{
expires 30d;
}
log_format access ‘$remote_addr — $remote_user [$time_local] “$request” ‘
‘$status $body_bytes_sent “$http_referer” ‘
‘”$http_user_agent” $http_x_forwarded_for’;
access_log /www/log/access.log access;
}
}
&lt;/pre&gt;
&lt;/div&gt;
&lt;div class="section" id="fastcgi"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id23"&gt;关于FastCGI 的几个指令：&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;fastcgi_cache_path /usr/local/nginx/fastcgi_cache levels=1:2 keys_zone=TEST:10minactive=5m;&lt;/p&gt;
&lt;p&gt;这个指令为FastCGI 缓存指定一个路径，目录结构等级，关键字区域存储时间和非活动删除时间。&lt;/p&gt;
&lt;p&gt;fastcgi_connect_timeout 300;&lt;/p&gt;
&lt;p&gt;指定连接到后端FastCGI 的超时时间。&lt;/p&gt;
&lt;p&gt;fastcgi_send_timeout 300;&lt;/p&gt;
&lt;p&gt;向FastCGI 传送请求的超时时间，这个值是指已经完成两次握手后向FastCGI 传送请求的超时时间。&lt;/p&gt;
&lt;p&gt;fastcgi_read_timeout 300;&lt;/p&gt;
&lt;p&gt;接收FastCGI 应答的超时时间，这个值是指已经完成两次握手后接收FastCGI 应答的超时时间。&lt;/p&gt;
&lt;p&gt;fastcgi_buffer_size 4k;&lt;/p&gt;
&lt;p&gt;指定读取FastCGI 应答第一部分需要用多大的缓冲区，一般第一部分应答不会超过1k，由于页面大小为4k，所以这里设置为4k。&lt;/p&gt;
&lt;p&gt;fastcgi_buffers 8 4k;&lt;/p&gt;
&lt;p&gt;指定本地需要用多少和多大的缓冲区来缓冲FastCGI 的应答。&lt;/p&gt;
&lt;p&gt;fastcgi_busy_buffers_size 8k;&lt;/p&gt;
&lt;p&gt;这个指令我也不知道是做什么用，只知道默认值是fastcgi_buffers 的两倍。&lt;/p&gt;
&lt;p&gt;fastcgi_temp_file_write_size 8k;&lt;/p&gt;
&lt;p&gt;在写入fastcgi_temp_path 时将用多大的数据块，默认值是fastcgi_buffers 的两倍。&lt;/p&gt;
&lt;p&gt;fastcgi_cache TEST&lt;/p&gt;
&lt;p&gt;开启FastCGI 缓存并且为其制定一个名称。个人感觉开启缓存非常有用，可以有效降低CPU 负载，并且防止502 错误。&lt;/p&gt;
&lt;p&gt;fastcgi_cache_valid 200 302 1h;
fastcgi_cache_valid 301 1d;
fastcgi_cache_valid any 1m;&lt;/p&gt;
&lt;p&gt;为指定的应答代码指定缓存时间，如上例中将200，302 应答缓存一小时，301 应答缓存1 天，其他为1 分钟。&lt;/p&gt;
&lt;p&gt;fastcgi_cache_min_uses 1;&lt;/p&gt;
&lt;p&gt;缓存在fastcgi_cache_path 指令inactive 参数值时间内的最少使用次数，如上例，如果在5 分钟内某文件1 次也没有被使用，那么这个文件将被移除。&lt;/p&gt;
&lt;p&gt;fastcgi_cache_use_stale error timeout invalid_header http_500;&lt;/p&gt;
&lt;p&gt;不知道这个参数的作用，猜想应该是让nginx 知道哪些类型的缓存是没用的。以上为nginx 中FastCGI 相关参数，另外，FastCGI 自身也有一些配置需要进行优化，如果你使用php-fpm 来管理FastCGI，可以修改配置文件中的以下值：&lt;/p&gt;
&lt;p&gt;60&lt;/p&gt;
&lt;p&gt;同时处理的并发请求数，即它将开启最多60 个子线程来处理并发连接。&lt;/p&gt;
&lt;p&gt;102400&lt;/p&gt;
&lt;p&gt;最多打开文件数。&lt;/p&gt;
&lt;p&gt;204800&lt;/p&gt;
&lt;p&gt;每个进程在重置之前能够执行的最多请求数。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="ulimit"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id24"&gt;ulimit关于系统连接数的优化&lt;/a&gt;&lt;/h2&gt;
&lt;p id="ulimit-label"&gt;linux 默认值 open files 和 max user processes 为 1024&lt;/p&gt;
&lt;p&gt;#ulimit -n&lt;/p&gt;
&lt;p&gt;1024&lt;/p&gt;
&lt;p&gt;#ulimit –u&lt;/p&gt;
&lt;p&gt;1024&lt;/p&gt;
&lt;p&gt;问题描述： 说明 server 只允许同时打开 1024 个文件，处理 1024 个用户进程&lt;/p&gt;
&lt;p&gt;使用ulimit -a 可以查看当前系统的所有限制值，使用ulimit -n 可以查看当前的最大打开文件数。&lt;/p&gt;
&lt;p&gt;新装的linux 默认只有1024 ，当作负载较大的服务器时，很容易遇到error: too many open files 。因此，需要将其改大。&lt;/p&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;p&gt;使用 ulimit –n 65535 可即时修改，但重启后就无效了。（注ulimit -SHn 65535 等效 ulimit -n 65535 ，-S 指soft ，-H 指hard)&lt;/p&gt;
&lt;div class="section" id="id9"&gt;
&lt;h3&gt;&lt;a class="toc-backref" href="#id25"&gt;修改方式&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有如下三种修改方式：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;在/etc/rc.local 中增加一行 ulimit -SHn 65535&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;在/etc/profile 中增加一行 ulimit -SHn 65535&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;在/etc/security/limits.conf 最后增加:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
* soft nofile 65535
* hard nofile 65535
* soft nproc 65535
* hard nproc 65535
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;具体使用哪种，在 CentOS 中使用第1 种方式无效果，使用第3 种方式有效果，而在Debian 中使用第2 种有效果&lt;/p&gt;
&lt;p&gt;# ulimit -n&lt;/p&gt;
&lt;p&gt;65535&lt;/p&gt;
&lt;p&gt;# ulimit -u&lt;/p&gt;
&lt;p&gt;65535&lt;/p&gt;
&lt;p&gt;备注：ulimit 命令本身就有分软硬设置，加-H 就是硬，加-S 就是软默认显示的是软限制&lt;/p&gt;
&lt;p&gt;soft 限制指的是当前系统生效的设置值。 hard 限制值可以被普通用户降低。但是不能增加。 soft 限制不能设置的比 hard 限制更高。 只有 root 用户才能够增加 hard 限制值。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">创e</dc:creator><pubDate>Fri, 25 Oct 2013 10:20:00 +0800</pubDate><guid>tag:opslinux.com,2013-10-25:post/2013-10-25-nginxda-zao-3wgao-bing-fa-wang-zhan/</guid><category>nginx</category><category>高并发</category><category>web</category></item><item><title>使用Vagrant打造你的虚拟环境</title><link>http://opslinux.com/post/2013-09-14-shi-yong-vagrantda-zao-ni-de-xu-ni-huan-jing/</link><description>&lt;h1 id="vagrant"&gt;使用Vagrant打造你的虚拟环境&lt;/h1&gt;
&lt;p&gt;因为要做mongDB的replication+sharding的实验，领导给我推荐Vagrant来模拟虚拟环境做部署实践，稍微了解够大为震惊，因网上文档不是特别容易理解，留下一份以备后用&lt;/p&gt;
&lt;p&gt;vagrant的强大在于是一个镜像，配置完以后镜像可以放到任何地方去，真正做到了一劳永逸了。&lt;/p&gt;
&lt;p&gt;总结一下自己使用vagrant的一点笔记，以免以后忘记还得再去翻官方文档。&lt;/p&gt;
&lt;p&gt;vagrant的官方网站：http://www.vagrantup.com/ 现在又改版了，挺漂亮的。&lt;/p&gt;
&lt;p&gt;vagrant的一些镜像：http://www.vagrantbox.es/ 各种linux都有。
然后按照官方说的，执行这三部，然后一个虚拟机就起来了。
注：先要安装VirtualBox&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置box&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;vagrant box add debian http://ergonlogic.com/files/boxes/debian-current.box  &lt;span class="c"&gt;#增加一个box,debian就是box的title 后面跟vagrant上的virtualbox镜像地址&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;vagrant init debian &lt;span class="c"&gt;#初始化debian&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;vagrant up   &lt;span class="c"&gt;#这个是真正的启动&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意国内网速访问很慢 这里可以先去 &lt;code&gt;http://www.vagrantbox.es/&lt;/code&gt; 下载你需要的镜像 然后把http那行直接换成你本地镜像的路径就ok比较方便和快捷&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;连接虚拟主机&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你会看到终端显示了启动过程，启动完成后，我们就可以用 SSH 登录虚拟机了，剩下的步骤就是在虚拟机里配置你要运行的各种环境和参数了。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;vagrant ssh  &lt;span class="c"&gt;# SSH 登录 ssh的后面可以跟你的title来连接不同的vm主机&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;打包分发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当你配置好开发环境后，退出并关闭虚拟机。在终端里对开发环境进行打包：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;vagrant package
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;打包完成后会在当前目录生成一个 package.box 的文件，将这个文件传给其他用户，其他用户只要添加这个 box 并用其初始化自己的开发目录就能得到一个一模一样的开发环境了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常用命令&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;vagrant init  &lt;span class="c"&gt;# 初始化&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;vagrant up  &lt;span class="c"&gt;# 启动虚拟机&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;vagrant halt  &lt;span class="c"&gt;# 关闭虚拟机&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;vagrant reload  &lt;span class="c"&gt;# 重启虚拟机&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;vagrant ssh  &lt;span class="c"&gt;# SSH 至虚拟机&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;vagrant status  &lt;span class="c"&gt;# 查看虚拟机运行状态&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;vagrant destroy  &lt;span class="c"&gt;# 销毁当前虚拟机&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;box管理&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$vagrant&lt;/span&gt; box list
&lt;span class="nv"&gt;$vagrant&lt;/span&gt; box add
&lt;span class="nv"&gt;$vagrant&lt;/span&gt; box remove
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;更多内容请查阅官方文档 http://docs.vagrantup.com/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Multi-VM 多虚拟机&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;VAGRANTFILE_API_VERSION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;2&amp;quot;&lt;/span&gt;    &lt;span class="c"&gt;#定义版本&lt;/span&gt;
Vagrant.configure&lt;span class="o"&gt;(&lt;/span&gt;VAGRANTFILE_API_VERSION&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; |config|  &lt;span class="c"&gt;#使用内部2版本&lt;/span&gt;
  config.vm.define :debian1 &lt;span class="k"&gt;do&lt;/span&gt; |debian1|   &lt;span class="c"&gt;#定义第一台虚拟机，||里面就类似一个变量设置参数时使用 &lt;/span&gt;
     debian1.vm.box &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;debian1&amp;quot;&lt;/span&gt;             &lt;span class="c"&gt;#设置box名为debian1&lt;/span&gt;
     debian1.vm.host_name &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;debian1&amp;quot;&lt;/span&gt;      &lt;span class="c"&gt;#设置hostname为debian1&lt;/span&gt;
     debian1.vm.network :private_network, ip: &lt;span class="s2"&gt;&amp;quot;192.168.1.11&amp;quot;&lt;/span&gt; &lt;span class="c"&gt;#设置网络为内部网络 ip为192.168.1.11&lt;/span&gt;
  end
  config.vm.define :debian2 &lt;span class="k"&gt;do&lt;/span&gt; |debian2|
     debian2.vm.box &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;debian2&amp;quot;&lt;/span&gt;
     debian2.vm.host_name &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;debian2&amp;quot;&lt;/span&gt;
     debian2.vm.network :private_network, ip: &lt;span class="s2"&gt;&amp;quot;192.168.1.12&amp;quot;&lt;/span&gt;
  end
  config.vm.define :debian3 &lt;span class="k"&gt;do&lt;/span&gt; |debian3|
     debian3.vm.box &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;debian3&amp;quot;&lt;/span&gt;
     debian3.vm.host_name &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;debian3&amp;quot;&lt;/span&gt;
     debian3.vm.network :private_network, ip: &lt;span class="s2"&gt;&amp;quot;192.168.1.13&amp;quot;&lt;/span&gt;
  end

end
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意语法格式就好，配置前关闭虚拟机，配置完后打开虚拟机。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用 Apache/Nginx 时会出现诸如图片修改后但页面刷新仍然是旧文件的情况，是由于静态文件缓存造成的。需要对虚拟机里的 Apache/Nginx 配置文件进行修改：&lt;/p&gt;
&lt;p&gt;Apache 配置添加:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;EnableSendfile off
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Nginx 配置添加:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sendfile off;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">创e</dc:creator><pubDate>Sat, 14 Sep 2013 00:00:00 +0800</pubDate><guid>tag:opslinux.com,2013-09-14:post/2013-09-14-shi-yong-vagrantda-zao-ni-de-xu-ni-huan-jing/</guid><category>vagrant</category></item><item><title>zabbix监控mongoDB</title><link>http://opslinux.com/post/2013-09-09-zabbixjian-kong-mongodb/</link><description>&lt;h1 id="zabbixmongodb"&gt;zabbix监控mongoDB&lt;/h1&gt;
&lt;p&gt;推荐文档：&lt;/p&gt;
&lt;p&gt;官方推荐：http://docs.mongodb.org/manual/administration/monitoring/&lt;/p&gt;
&lt;p&gt;因我使用的是zabbix.所以选择：&lt;/p&gt;
&lt;p&gt;https://code.google.com/p/mikoomi/wiki/03&lt;/p&gt;
&lt;p&gt;插件下载地址：&lt;/p&gt;
&lt;p&gt;http://mikoomi.googlecode.com/svn/plugins/MongoDB%20Plugin/&lt;/p&gt;
&lt;p&gt;学习地址：&lt;/p&gt;
&lt;p&gt;https://blog.serverdensity.com/mongodb-monitoring-db-serverstatus/&lt;/p&gt;
&lt;p&gt;http://www.yaukb.com/2012/05/zabbix_mongodb/&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.在Zabbix Server上安装php MongoDB驱动：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[root@localhost conf.d]# pecl install mongo&lt;br /&gt;
WARNING: channel “pecl.php.net” has updated its protocols, use “pecl channel-update pecl.php.net” to update
downloading mongo-1.4.3.tgz …
Starting to download mongo-1.4.3.tgz (140,481 bytes)
…………………………done: 140,481 bytes
84 source files, building
running: phpize
Configuring for:
PHP Api Version:         20100412
Zend Module Api No:      20100525
Zend Extension Api No:   220100525&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;Build process completed successfully
Installing ‘/usr/lib64/php/modules/mongo.so’
install ok: channel://pecl.php.net/mongo-1.4.3
configuration option “php_ini” is not set to php.ini location
You should add “extension=mongo.so” to php.ini
You have new mail in /var/spool/mail/root&lt;/p&gt;
&lt;p&gt;[root@localhost conf.d]# vim /etc/php.ini&lt;br /&gt;
[root@localhost conf.d]# /etc/init.d/httpd reload&lt;br /&gt; 
[root@localhost conf.d]# php -m |grep mongo&lt;br /&gt;
mongo&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.下载：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[root@localhost externalscripts]# pwd&lt;br /&gt;
/etc/zabbix/externalscripts&lt;br /&gt;
[root@localhost externalscripts]# wget http://mikoomi.googlecode.com/svn/plugins/MongoDB%20Plugin/mikoomi-mongodb-plugin.php&lt;br /&gt;
[root@localhost externalscripts]# wget http://mikoomi.googlecode.com/svn/plugins/MongoDB%20Plugin/mikoomi-mongodb-plugin.sh&lt;br /&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.导入模板 建立主机：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将MongoDB_Plugin_template_export.xml导入到zabbix中
修改"Miscellaneous: Data Collector"监控项的key值，因默认提供的值有错误：
mikoomi-mongodb-plugin.sh["--", "-h", "{$MONGODB_HOSTNAME}", "-p", "{$MONGODB_PORT}", "-z", "{$MONGODB_ZABBIX_NAME}"]&lt;/p&gt;
&lt;p&gt;在zabbix里建立主机，定义宏：&lt;br /&gt;
{$MONGODB_HOSTNAME} = 10.0.199.30   #即ip地址&lt;br /&gt;
{$MONGODB_PORT} = 27017 #监控mongdb的端口号&lt;br /&gt;
{$MONGODB_ZABBIX_NAME} =MongDB1 #hostname 就是主机名 不要写显示名 这样会接受不到数据 一定是hostname&lt;br /&gt;
然后给主机连接上模板即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.测试：&lt;br /&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[root@localhost externalscripts]# ./mikoomi-mongodb-plugin.sh -D -h10.0.199.30 -p27017 -z MongDB1
0
[root@localhost externalscripts]# less /tmp/mikoomi-mongodb-plugin.php_MongoDB1.log&lt;/p&gt;
&lt;p&gt;mikoomi-mongodb-plugin.php:Successfully connected to mongoDB using connect string root:passworda@MongDB1:27017
zabbix_sender [8413]: Warning: [line 66] ‘Key value’ required&lt;/p&gt;
&lt;p&gt;zabbix_sender [8413]: Warning: [line 68] ‘Key value’ required&lt;/p&gt;
&lt;p&gt;zabbix_sender [8414]: DEBUG: answer [{&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="s"&gt;&amp;quot;response&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;success&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;

    &lt;span class="s"&gt;&amp;quot;info&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Processed 58 Failed 13 Total 71 Seconds spent 0.001618&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;sent: 71; skipped: 2; total: 73&lt;/p&gt;
&lt;p&gt;/tmp/mikoomi-mongodb-plugin.php_MongDB1.log (END)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;若出现  Failed 的数目和 Total数目相等的话 应该是  mikoomi-mongodb-plugin.sh 后面-z参数的 hostname没写对 这个hostname是zabbix主机的hostname即主机名 而不是显示名&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">创e</dc:creator><pubDate>Mon, 09 Sep 2013 00:00:00 +0800</pubDate><guid>tag:opslinux.com,2013-09-09:post/2013-09-09-zabbixjian-kong-mongodb/</guid><category>zabbix</category></item><item><title>使用github和pelican搭建本站博客</title><link>http://opslinux.com/post/2013-07-13-shi-yong-githubhe-pelicanda-jian-ben-zhan-bo-ke/</link><description>&lt;h2 id="githubpelican"&gt;使用github和pelican搭建本站博客&lt;/h2&gt;
&lt;h3 id="virtualenv"&gt;安装virtualenv虚拟环境&lt;/h3&gt;
&lt;p&gt;安装虚拟环境是为了防止污染，linux本身的python环境&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;easy_install&lt;/span&gt; &lt;span class="n"&gt;virtualenv&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="virtualenv_1"&gt;使用virtualenv&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;virtualenv pelican   &lt;span class="c"&gt;#创建虚拟环境&lt;/span&gt;
&lt;span class="nb"&gt;cd &lt;/span&gt;pelican
&lt;span class="nb"&gt;source &lt;/span&gt;bin/activate   &lt;span class="c"&gt;#激活虚拟环境&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="pelicanmarkdown"&gt;安装pelican和markdown&lt;/h3&gt;
&lt;p&gt;pelican 就是生成静态博客的程序&lt;br /&gt;
markdow 是写博客使用的轻量级标记语言,不会使用的同学可以查看&lt;a href="http://wowubuntu.com/markdown/"&gt;帮助&lt;/a&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;pelican&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;Markdown&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;pip&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;ghp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;import&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="blog"&gt;建立blog目录&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;mkdir&lt;/span&gt; &lt;span class="n"&gt;myblog&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;myblog&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_1"&gt;开始创建&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;pelican&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;quickstart&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;基本按照提示设置就可以，稍后可以在pelicanconf.py文件中手动修改。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;.
|-- content &lt;span class="c"&gt;#所有文章放于此目录&lt;/span&gt;
|-- develop_server.sh  &lt;span class="c"&gt;#用于开启测试服务器&lt;/span&gt;
|-- Makefile   &lt;span class="c"&gt;#方便管理博客的Makefile&lt;/span&gt;
|-- output &lt;span class="c"&gt;#静态生成文件&lt;/span&gt;
|-- pelicanconf.py &lt;span class="c"&gt;#配置文件&lt;/span&gt;
|-- publishconf.py &lt;span class="c"&gt;#配置文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_2"&gt;写一篇文章&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;content&lt;/code&gt;目录新建一个&lt;code&gt;test.md&lt;/code&gt;文件, 填入一下内容:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Title: 文章标题
Date: 2013-04-18
Category: 文章类别
Tag: 标签1, 标签2    
这里是内容
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后执行:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;html&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;用以生成html&lt;/p&gt;
&lt;p&gt;然后执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;develop_server&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;开启一个测试服务器, 这会在本地 8000 端口建立一个测试web服务器, 可以使用浏览器打开:&lt;code&gt;http://localhost:8000&lt;/code&gt;来访问这个测试服务器, 然后就可以欣赏到你的博客了&lt;/p&gt;
&lt;h3 id="github"&gt;Github上的准备&lt;/h3&gt;
&lt;p&gt;在Github上创建一个新项目，把这个项目clone到myblog文件夹下。然后按照Github的规定建立一个没有父节点的分支gh-pages。&lt;br /&gt;
注：在是用分支创建github的blog的时候，要先确保自己的github上有例如：zbing3.github.io命名的项目并且在&lt;code&gt;settings&lt;/code&gt;中开启Github Pages
如图：
&lt;img alt="Alt Github Pages" src="/static/upload/20130713144403.jpg" /&gt;
点击&lt;code&gt;Automatic Page Generator&lt;/code&gt;开启Github Pages服务&lt;/p&gt;
&lt;p&gt;进入output目录中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git init
&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout --orphan gh-pages
&lt;span class="nv"&gt;$ &lt;/span&gt;git add .
&lt;span class="nv"&gt;$ &lt;/span&gt;git commit -m &lt;span class="s2"&gt;&amp;quot;first post&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;git remote add origin git@github.com:zbing3/opslinux.git
&lt;span class="nv"&gt;$ &lt;/span&gt;git push origin gh-pages
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样上传完代码等10分钟左右，即可在浏览器中使用&lt;code&gt;http://zbing3.github.io/myblog&lt;/code&gt;就能访问到自己的博客&lt;/p&gt;
&lt;h3 id="makefilegit"&gt;定制自己的Makefile文件，让git提交更方便一点&lt;/h3&gt;
&lt;p&gt;使用此方法就不用在output目录中初始git了。编辑Makefile &lt;code&gt;vim Makefile&lt;/code&gt; ，在github下面添加如下格式的文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;git:&lt;/span&gt;
    &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PELICAN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;INPUTDIR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OUTPUTDIR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CONFFILE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PELICANOPTS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;ghp&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;OUTPUTDIR&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;push&lt;/span&gt; &lt;span class="n"&gt;origin&lt;/span&gt; &lt;span class="n"&gt;gh&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pages&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ghp-import 是用来Easily import docs to your gh-pages branch，就是方便添加到gh-pages分支的，这个分支github才能解析我们的html嘛。
接着以后：&lt;code&gt;make git&lt;/code&gt; 就可以直接提交到git的gh-pages分支的&lt;/p&gt;
&lt;h3 id="pelican"&gt;pelican的备份&lt;/h3&gt;
&lt;p&gt;因为有时候要换电脑，所以肯定要把你的pelican的博客环境做备份，以便换完电脑后快速的搭建出写博客的环境&lt;/p&gt;
&lt;p&gt;进入blog目录：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git branch &lt;span class="c"&gt;#查看本地分支，没有master所以要创建 如果有master就跳过创建&lt;/span&gt;
  gh-pages
&lt;span class="nv"&gt;$ &lt;/span&gt;git branch master &lt;span class="c"&gt;#创建master分支&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout master &lt;span class="c"&gt;#切换到master分支&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;git add .
&lt;span class="nv"&gt;$ &lt;/span&gt;git commit -m &lt;span class="s2"&gt;&amp;quot;first post&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;git remote add origin git@github.com:zbing3/opslinux.git &lt;span class="c"&gt;#添加过origin就不用添加&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;git push origin master  &lt;span class="c"&gt;#有事提交报错，如因原来提交过master分支起冲突，就在后面追加--froce&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="_3"&gt;未完待续……&lt;/h2&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">创e</dc:creator><pubDate>Sat, 13 Jul 2013 00:00:00 +0800</pubDate><guid>tag:opslinux.com,2013-07-13:post/2013-07-13-shi-yong-githubhe-pelicanda-jian-ben-zhan-bo-ke/</guid><category>pelican</category><category>github</category></item><item><title>about</title><link>http://opslinux.com/post/2013-07-12-about/</link><description>&lt;p&gt;一个老运维人员正在转python开发中……&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">创e</dc:creator><pubDate>Fri, 12 Jul 2013 00:00:00 +0800</pubDate><guid>tag:opslinux.com,2013-07-12:post/2013-07-12-about/</guid></item><item><title>helloworld</title><link>http://opslinux.com/post/2013-07-12-helloworld/</link><description>&lt;p&gt;总想找个地方写博客，分享下自己所学的东西，原来因为种种原因一直没坚持下来，这次用了github和pelican搭建了个静态博客，使用git上传真的很爽，就是markdown这玩应我不是太会用，还的慢慢学学，大家都说他好用，我也不知道到为什么，学着看吧与大家共勉，开源世界的软件，总能给人们带来美好的东西。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">创e</dc:creator><pubDate>Fri, 12 Jul 2013 00:00:00 +0800</pubDate><guid>tag:opslinux.com,2013-07-12:post/2013-07-12-helloworld/</guid><category>随笔</category></item></channel></rss>